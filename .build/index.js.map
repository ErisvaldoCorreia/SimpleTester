{
  "version": 3,
  "sources": ["../index.ts"],
  "sourcesContent": ["//Iniciando estudos sobre processos internos dos testes unit\u00E1rios.\n\nfunction somarValores(valueA: number, valueB: number) {\n  return valueA + valueB;\n}\n\nfunction subtrairValores(valueA: number, valueB: number) {\n  return valueA - valueB;\n}\n\n/* \nFun\u00E7\u00F5es que ser\u00E3o usadas para realizar o teste. VERS\u00C3O 0.0.5\nNesta modifica\u00E7\u00E3o iremos aplicar alguns detalhes para tornar os testes\nsimulados mais pr\u00F3ximos de um framework de testes reais.\n\nNesta fun\u00E7\u00E3o tester temos um processo de valida\u00E7\u00E3o simples onde ao executarmos a chamada\ndo tester, informamos 3 parametros: \n - o nome do teste que queremos realizar;\n - o valor ou fun\u00E7\u00E3o a ser testado;\n - o resultado que esperamos como comparativo;\n*/\nlet countSuccess = 0;\nlet countFails = 0;\n\n// Iniciando as fun\u00E7\u00F5es de valida\u00E7\u00E3o e matchers\nconst valideQue = (valorBase: any) => {\n  \n  // subconjunto de asser\u00E7\u00F5es (matchers) para valida\u00E7\u00E3o\n  const assertions = {\n\n    // matcher de igualdade.\n    // retorna um erro em caso de comparacao falsa\n    sejaIgual(comparativo: any){\n      if(valorBase !== comparativo) {\n        throw{}; \n      } \n    }\n    \n  };\n\n  return assertions;\n}\n\n// Refatorando a fun\u00E7\u00E3o tester para usar com as asser\u00E7\u00F5es;\nconst tester = (nameTeste: string, funcaoAssertiva: any) => {\n  try {\n    funcaoAssertiva();\n    countSuccess++;\n    console.log(`\\u001b[42;1;37m PASS: \\u001b[0;32m ${nameTeste}`);\n  } catch (err) {\n    countFails++;\n    console.log(`\\u001b[41;1;37m FAIL: \\u001b[0;31m ${nameTeste}`);\n  };\n}\n\nconst handleOutputTest = () => {\n  return console.log(`\\u001b[0;36m \n----------------------------------------------\n  Total:   ${countSuccess + countFails}\n  Sucesso: ${countSuccess}\n  Falhas:  ${countFails}\n  \\u001b[0mFim dos Testes.\\u001b[0;36m\n----------------------------------------------\n  `);\n}\n\n// Fun\u00E7\u00E3o para agrupar os testes por grupo.\nconst grupoTester = (nameTeste: string, funcoes: CallableFunction) => {\n  // usando o scape code u001b para modos stricts.\n  countFails = 0;\n  countSuccess = 0;\n  console.log(`\\u001b[0;36m ${nameTeste}\\n`);\n  funcoes();\n  handleOutputTest();\n}\n\n// Executando os testes dentro do grupoTester com matchers aplicados.\ngrupoTester('Testando novo modelo aplicando matchers', () => {\n  tester('Soma de Valores correta', () => {\n    const retornado = somarValores(2,2);\n    const esperado = 4;\n    valideQue(retornado).sejaIgual(esperado);\n  } );\n  \n  tester('Subtrair valores corretamente', () => {\n    const retornado = subtrairValores(2,2);\n    const esperado = 0;\n    valideQue(retornado).sejaIgual(esperado);\n  });\n\n   tester('Subtrair valores erroneamente', () => {\n    const retornado = subtrairValores(2,1);\n    const esperado = 2;\n    valideQue(retornado).sejaIgual(esperado);\n  });\n});\n\n\n//Estamos recebendo um any nos tipos por conta das possibilidades.\n//A compara\u00E7\u00E3o pode ser por fun\u00E7\u00E3o, string, number.\n//VERS\u00C3O INICIAL DO MODELO TESTER. SEM USO DE ASSER\u00C7\u00D5ES.\n//Podemos utilizar esse modelo antigo funcionamente no grupoTester\nconst oldTester = (nameTeste: string ,valorBase: any, comparativo: any) => {\n  if(valorBase === comparativo) {\n    countSuccess++;\n    console.log(`\\u001b[42;1;37m PASS: \\u001b[0;32m ${nameTeste}`);\n  } else {\n    countFails++;\n    console.log(`\\u001b[41;1;37m FAIL: \\u001b[0;31m ${nameTeste}`);\n  }\n}\n\n/*\nModelo de estudo inicial...\ncriando linhas de testes isolados e linhas agrupadas sem asser\u00E7\u00F5es.\n\n// Executando os testes isoladamente.\noldTester('Soma de Valores correta', somarValores(2,2), 4);\noldTester('Nova Soma de Valores correta', somarValores(5,2), 7);\noldTester('Subtrair valores corretamente', subtrairValores(5,2), 3);\noldTester('Este teste deve falhar', subtrairValores(5,2), 7);\noldTester('Teste deve retornar como erro', somarValores(3,3), 7);\n\n// Executando os testes dentro do grupoTester.\ngrupoTester('Testes que devem passar', () => {\n  oldTester('Soma de Valores correta', somarValores(2,2), 4);\n  oldTester('Subtrair valores corretamente', subtrairValores(5,2), 3);\n});\n\ngrupoTester('Um teste passa e outro falha', () => {\n  oldTester('Soma de Valores correta', somarValores(2,2), 4);\n  oldTester('Teste deve retornar como erro', somarValores(3,3), 7);\n});\n\nAdicionando Cores ao Console.\nconsole.log(\"\\033[31mAqui esta o texto em vermelho.\")\nconsole.log(\"\\033[0;32mAqui esta o texto em verde.\")\nconsole.log(\"\\033[41;1;37m Fundo Vermelho \\033[0m --> Fundo Vermelho\")\nconsole.log(\"\\033[42;1;37m Fundo Verde \\033[0m --> Fundo Verde\")\n\nem arquivos que apresentem erro de legacy octal escape, podemos subistituir\no escape 033 por u001b, assim conseguindo rodar as cores no modo strict mode.\n*/\n"],
  "mappings": "AAEA,sBAAsB,QAAgB,QAAgB;AACpD,SAAO,SAAS;AAAA;AAGlB,yBAAyB,QAAgB,QAAgB;AACvD,SAAO,SAAS;AAAA;AAclB,IAAI,eAAe;AACnB,IAAI,aAAa;AAGjB,MAAM,YAAY,CAAC,cAAmB;AAGpC,QAAM,aAAa;AAAA,IAIjB,UAAU,aAAiB;AACzB,UAAG,cAAc,aAAa;AAC5B,cAAK;AAAA;AAAA;AAAA;AAMX,SAAO;AAAA;AAIT,MAAM,SAAS,CAAC,WAAmB,oBAAyB;AAC1D,MAAI;AACF;AACA;AACA,YAAQ,IAAI,4BAAsC;AAAA,WAC3C,KAAP;AACA;AACA,YAAQ,IAAI,4BAAsC;AAAA;AACnD;AAAA;AAGH,MAAM,mBAAmB,MAAM;AAC7B,SAAO,QAAQ,IAAI;AAAA;AAAA,aAER,eAAe;AAAA,aACf;AAAA,aACA;AAAA;AAAA;AAAA;AAAA;AAOb,MAAM,cAAc,CAAC,WAAmB,YAA8B;AAEpE,eAAa;AACb,iBAAe;AACf,UAAQ,IAAI,WAAgB;AAAA;AAC5B;AACA;AAAA;AAIF,YAAY,2CAA2C,MAAM;AAC3D,SAAO,2BAA2B,MAAM;AACtC,UAAM,YAAY,aAAa,GAAE;AACjC,UAAM,WAAW;AACjB,cAAU,WAAW,UAAU;AAAA;AAGjC,SAAO,iCAAiC,MAAM;AAC5C,UAAM,YAAY,gBAAgB,GAAE;AACpC,UAAM,WAAW;AACjB,cAAU,WAAW,UAAU;AAAA;AAGhC,SAAO,iCAAiC,MAAM;AAC7C,UAAM,YAAY,gBAAgB,GAAE;AACpC,UAAM,WAAW;AACjB,cAAU,WAAW,UAAU;AAAA;AAAA;AASnC,MAAM,YAAY,CAAC,WAAmB,WAAgB,gBAAqB;AACzE,MAAG,cAAc,aAAa;AAC5B;AACA,YAAQ,IAAI,4BAAsC;AAAA,SAC7C;AACL;AACA,YAAQ,IAAI,4BAAsC;AAAA;AAAA;",
  "names": []
}
